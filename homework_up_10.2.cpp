// homework_up_10.2.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
// Задача 10.2 урок "Сематника перемещений", модуль - продвинутое программирование.
// Нужно реализовать класс для работы с большими числами, которые не помещаются в стандартные типы данных
// для этого нужно определить методы
// конструктор перемещения
// перемещеющий оператор присваивания
// оператор сложения двух больших чисел
// оператор умножения на число
// для реализации этого класса можно использовать стринг или вектор

#include <iostream>
#include <string>
#include <math.h>

class big_number
{
public:
	char* ptr;

public:
	big_number(const char* s = "") : ptr(nullptr) //const char* s = "" - это значит мы содали указатель s на неизменяемые данные, и эти данные пустота. 
                                                  //переменная s доступна только для чтения, её нельзя поменять.    
		                                          // двоеточие используется для инициализации членов класса, то есть ptr = nullptr
	{
		if (s)
		{
			std::size_t n = std::strlen(s) + 1;      // std::strlen это функция, которая посчитает количество символов в строке, которая ей передана и вернёт их число.
			                                 // Это означает, что мы получим число 5 плюс 1 и n будет равно шести
			ptr = new char[n];              // здесь мы создали указатель, оно же массив чаров, длиной 6. То есть там 6 ячеек, от 0 до 5
			std::memcpy(ptr, s, n);          // Копирует байты в количестве n из объекта, на который указывает s , в объект, на который указывает ptr 
			                                 // Оба объекта интерпретируются как массивы unsigned char .
			                                 // у нас копируется 6 байт, каждый байт это 8 бит, то есть 8 лампочек. Бит принимает значение 0 или 1.   
		}
		std::cout << "Constructor" << std::endl; // в итоге у нас появился объект big_number, в котором находится поле, 
		                                         // и это поле у нас указатель на массив из шести чаров. Это 12345. или в двоичном виде 31 32 33 34 35 00
	}
	~big_number()
	{
		delete[] ptr;                             // освобождаю память.
		//ptr = nullptr;                            // убираю указатель 
		std::cout << "Destructor" << std::endl;
	};

	big_number(const big_number& other): big_number(other.ptr)         // конструктор копирования 
	                                              // вызывается конструктор, который воздаёт такой же объект, как и первочальный, только по другому адресу 
	{                                             // в результате у нас получается копия старого объекта, которая лежит по новому адресу.  
		std::cout << "Копирование типа a (b)" << std::endl;  // фактически мы делаем копию b, и называем её a
	}

	big_number(big_number&& other) noexcept       // конструктор перемещения
		: ptr(std::exchange(other.ptr, nullptr))  // функция std::exchange(other.ptr, nullptr) заменяет значение other.ptr на nullptr и возвращает старое значение other.ptr
	{                                             // в результате в первых скобках будет стоять значение указателя ptr
												  // насколько я понял, старое значение будет помещено в новый объект, и тем самым у старого объекта всё отняли и
												  // передали во владение новому объекту
		std::cout << "Moved" << std::endl;
	}

	big_number& operator = (const big_number& other) // оператор копирующего присваивания
	{
		std::cout << " Присваивание с копированием a = b " << std::endl;  
		return *this = big_number(other);                 // Здесь используется конструктор копирования. 

	}

	big_number& operator=(big_number&& other) noexcept // оператор перемещaющего присваивания
	{
		std::swap(ptr, other.ptr);
		std::cout << "Перемещающее присваивание" << std::endl;
		return *this;
	}
	
	big_number operator+(const big_number& other) // параметром в функцию мы должны принять второй объект, то есть number12, данные в нём массив чаров, то есть 44
		                                          // посмотрел в памяти, действительно, в other у нас данные это четвёрка, то есть приняли параметром второй объект
												  // интересно то, что данные в this.ptr это тоже массив чаров, то есть 66. 
												  // то есть если сложить эти данные, то можно их положить в данные объекта temp и будет результат
												  // вопрос с том как 
	
	{
		int n = 0, p = 1;
		std::size_t size = std::strlen(other.ptr); //выясняю размер объекта, который слева оператора плюс
		for (int i = 0; i < size; ++i)             //складываю два числа типа int, которые лежат в массивах типа char, последние в складываемых объектах
		{
			n = n + ((other.ptr[i] - '0') + (this->ptr[i] - '0')) * p;
			p *= 10;
		}                                         // сумма этих двух чисел находится с переменной n          
		
		big_number temp; // создал временный объект
		
		for (int i = size; i >= 0 ; i--)          // складываю числа из переменной n в массив типа char, последний находится во временном объекте temp
		{
			temp.ptr[i] = (n % 10) + '0';
			n = n / 10;
		}
		temp.ptr[size + 1] = '\0';
		std::cout << "Операция сложения" << std::endl;

		return temp;                // возвращаю объект temp, как результат сложения двух чисел и преобразования суммы в массив типа char
	}

	big_number operator*(const int& other) // получилось, то в other просто пятёрка, в в this.ptr у нас 66
	{
		
		

	int n = 0, p = 0, m = 0, count = 0;
	int mult = other;
		std::size_t size0 = std::strlen(this->ptr); // size0 это длина большого числа
		
		int num = 0;
		while (mult != 0)     // в этом цикле мы ищем длину числа, на которое нужно умножить, и кладём его в num                          
		{
			mult /= 10;
			num++;            
		}                                                
		mult = other;
		for (int j = 0; j < num; j++)
		{
			
			mult = mult % 10;              // Это цифты из числа, на которое нужно умножить. 
			
			n = 0, p = 0, m = 0;
			for (int i = (size0 - 1); i >= 0; i--)
			{
				n = this->ptr[i] - '0';
				//std::cout << n << std::endl;  // вывожу на печать числа из объекта слева от оператора *

				m = m + n * mult * pow(10, p); // Заполнил результат умножение первой цифры из первого числа на множитель
				//std::cout << m << std::endl;
				p = p + 1;
			}
			//std::cout << "Результат умножения промежуточный = " << m << std::endl;
			mult = other/ pow(10, j + 1);
			count = count + m * pow(10, j);
			//std::cout << "Результат умножения полный = " << count << std::endl;
		}
		//std::cout << "Результат умножения на число = " <<  count << std::endl;

		//std::cout << "Операция умножения на число" << std::endl;  // операция умножения на число проходит нормально, теперь нужно вывести на печать
		                                                          // объект типа big-number, для этого нужно полученный результат положить в массив типа чар 
																   // и этот массив положить в объект типа big_number  и отправить назад.

		
		num = 0;
		int count1 = count;
		while (count != 0)     //считаю число цифр в результате умножения                         
		{
			count /= 10;
			num++;
		}
		big_number temp; // создал временный объект 
		
		for (int i = num - 1; i >= 0; i--)          // складываю числа из переменной n в массив типа char, последний находится во временном объекте temp
		{                                               // здесь ошибка, выбрасывает исплючение. Нужно разобраться. 
			temp.ptr[i] = (count1 % 10) + '0';
			count1 = count1 / 10;
		}
		temp.ptr[num] = '\0';

		//temp.print();
		std::cout << "Оператор умножения на число" << std::endl;
		return temp;                // возвращаю объект temp, как результат сложения двух чисел и преобразования суммы в массив типа char
	}
	
	void print()
	{	
		std::cout << printf(ptr) << std::endl;
	}
};

int main()
{
	setlocale(LC_ALL, "ru");

	// Программа складывает большие числа только одинаковой длины (длина числа то число цифр в числе)
	// Программа умножает любые большие числа, то есть можно разные числа по длине.
	// 
	// Тестирование выдачи на печать
	big_number number1("12345");
	big_number number2("67892");

	number1.print(); // выдаёт на печать 123455, то есть лишная пятёрка в конце
	number2.print(); // выдаёт на печать 67892, то есть лишний символ

	// тестирование оператора копирования
	big_number number3("34567");
	number3.print();
	big_number number4(number3); // оператор копирования работает
	number4.print();
	

	// тестирование оператора перемещения
	
	big_number number5("6789");
	big_number number6(std::move(number5));
	number6.print();             
	
	// Тестирование оператора копирующего присваивания
	big_number number7("6789");
	big_number number8("8888");
	number7 = number8; // проверяем работу оператора копирующего присваивания, он нормально работает
	number7.print(); //
	

	// тестирование оператора перемещающего присваивания
	
	big_number number9("6789");
	big_number number10("11111");

	
	number10 = std::move(number9);  // поменяли местами содержимое объектов number9 и number10
	number10.print(); // оператор работает нормально
	
	
	std::cout << "Тестирование оператора +, это сложение больших чисел" << std::endl;
	big_number number11("66");
	big_number number12("44");
	
	big_number result;
	result = number11 + number12; // Работает, но с ошибками.

	result.print();
	
	
	std::cout << "Тестирование оператора *, это умножение большого числа на число" << std::endl;
	big_number number14("567");
	int mult;
	mult = 1566;
	result =  number14 * mult; // проблема возникает при втором вызове деструктора. Выбрасывает исключение. 
	                           // в остальном оператор работает нормально
							   // Есть подозрение, что это связано с владением и ошибками при удалении, то есть нужно применять сематнику перемещений. 
	
	result.print();
	
	return 0;
}

